<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚¨õ What is Rect? - Custom Painter Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background-color: #f8f9fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: #1a73e8;
            color: white;
            padding: 40px 0;
            margin-bottom: 40px;
        }

        header h1 {
            font-size: 2em;
            font-weight: 600;
            text-align: center;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #1a73e8;
            text-decoration: none;
            font-size: 1em;
            padding: 10px 15px;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .back-link:hover {
            background-color: #e8f0fe;
            transform: translateX(-3px);
        }

        .section {
            background-color: white;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h2 {
            font-size: 1.6em;
            font-weight: 600;
            color: #1a73e8;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e8f0fe;
        }

        h3 {
            font-size: 1.3em;
            font-weight: 600;
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 {
            font-size: 1.1em;
            font-weight: 600;
            color: #5a6c7d;
            margin-top: 20px;
            margin-bottom: 12px;
        }

        p {
            margin-bottom: 15px;
            color: #495057;
            line-height: 1.8;
        }

        ul,
        ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
            color: #495057;
            line-height: 1.8;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #d63384;
        }

        .code-block {
            background-color: #f4f4f4;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #1a73e8;
            position: relative;
        }

        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .copy-button:hover {
            background-color: #1557b0;
            transform: translateY(-1px);
        }

        .copy-button:active {
            transform: translateY(0);
        }

        .copy-button.copied {
            background-color: #28a745;
        }

        .code-block code {
            color: #2c3e50;
            background-color: transparent;
            padding: 0;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .info-box {
            background-color: #e8f0fe;
            border-left: 4px solid #1a73e8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .highlight-box {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .success-box {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .property-layout {
            display: flex;
            align-items: flex-start;
            margin-top: 15px;
        }

        .property-code {
            flex: 1.5;
            min-width: 0;
        }

        .property-image {
            flex: 1;
            text-align: center;
        }

        .property-image img {
            max-width: 70%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .image-caption {
            margin-top: 8px;
            color: #6c757d;
            font-size: 0.9em;
            font-style: italic;
        }

        hr {
            border: none;
            border-top: 2px solid #e8f0fe;
            margin: 30px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        th {
            background-color: #1a73e8;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 12px 20px;
            background-color: #1a73e8;
            color: #fff;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.4);
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            font-weight: 600;
        }

        .back-to-top.show {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .back-to-top:hover {
            background-color: #1557b0;
            transform: translateY(-2px);
        }

        .example-images {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 20px 0;
        }

        .example-item {
            width: 100%;
            text-align: center;
        }

        .example-item img {
            max-width: 100%;
            height: auto;
            width: auto;
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .example-item .image-caption {
            margin-top: 10px;
            color: #6c757d;
            font-size: 0.9em;
            font-style: italic;
        }

        @media (max-width: 900px) {
            .property-layout {
                flex-direction: column;
            }

            .property-image {
                margin-top: -10px;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="container">
            <h1>‚¨õ What is Rect?</h1>
        </div>
    </header>

    <div class="container">
        <a href="../index.html" class="back-link">‚Üê Back to Topics</a>

        <section class="section">
            <h2>üìö What is Rect?</h2>
            <p>
                <strong>Rect</strong> is a class in Flutter (from <code>dart:ui</code>) that represents an
                <strong>axis-aligned rectangle</strong> in logical pixels. It describes a region on the canvas using
                <strong>left</strong>, <strong>top</strong>, <strong>right</strong> and <strong>bottom</strong>
                coordinates.
            </p>
            <p><strong>Think of Rect as:</strong></p>
            <ul>
                <li>The <strong>box</strong> your shapes are drawn inside</li>
                <li>A <strong>bounding box</strong> around circles, paths, or widgets</li>
                <li>A convenient way to compute <strong>centers, corners, width and height</strong></li>
                <li>The region used for <strong>clipping, hit‚Äëtesting, and layout</strong> in CustomPainter</li>
            </ul>

            <div class="info-box">
                <strong>üí° Key Concept:</strong> <strong>Rect</strong> defines <strong>WHERE and HOW BIG</strong> your
                drawings are. Many Canvas methods (like <code>drawRect</code>, <code>drawArc</code>,
                <code>drawRRect</code>, gradients' <code>createShader</code>, etc.) use Rects to know the
                <strong>bounds</strong> of the drawing.
            </div>
        </section>

        <section class="section">
            <h2>üèóÔ∏è Creating Rects ‚Äì Essential Constructors</h2>

            <h3 id="rect-fromltwh"><code>Rect.fromLTWH(left, top, width, height)</code></h3>
            <p><strong>Purpose:</strong> Build a rect from <strong>L</strong>eft, <strong>T</strong>op,
                <strong>W</strong>idth and <strong>H</strong>eight.
            </p>
            <p><strong>Alternative:</strong> You can also create a Rect using the <code>&</code> operator:
                <code>Offset(left, top) & Size(width, height)</code>
            </p>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;final origin1 = Offset(20, 30);<br>
&nbsp;&nbsp;final origin2 = Offset(size.width / 2, size.height / 2);<br>
&nbsp;&nbsp;final rectSize = Size(100, 60);<br>
&nbsp;&nbsp;final rectSize2 = Size(80, 120);<br>
<br>
&nbsp;&nbsp;final rect1 = origin1 & rectSize;<br>
&nbsp;&nbsp;final rect2 = origin2 & rectSize2;<br>
&nbsp;&nbsp;final paint = Paint()..color = Colors.blue;<br>
&nbsp;&nbsp;canvas.drawRect(rect1, paint);<br>
&nbsp;&nbsp;canvas.drawRect(rect2, paint);<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/rect-from-ltwh.png" alt="Flutter Rect fromLTWH visual example">
                    <p class="image-caption">Visual guide showing how <code>Rect.fromLTWH()</code> or the
                        <code>&</code> operator creates rectangles from an origin point (top-left corner) and size
                        (width and height). Two blue rectangles are shown: one horizontal rectangle in the upper-left
                        and one vertical rectangle centered on the screen.
                    </p>
                </div>
            </div>

            <h3 id="rect-fromltrb"><code>Rect.fromLTRB(left, top, right, bottom)</code></h3>
            <p><strong>Purpose:</strong> Create a rect when you already know all four edges: <strong>L</strong>eft,
                <strong>T</strong>op, <strong>R</strong>ight, and <strong>B</strong>ottom.
            </p>
            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>left</code> - X coordinate of the left edge</li>
                <li><code>top</code> - Y coordinate of the top edge</li>
                <li><code>right</code> - X coordinate of the right edge</li>
                <li><code>bottom</code> - Y coordinate of the bottom edge</li>
            </ul>
            <p><strong>Note:</strong> The width is calculated as <code>right - left</code> and height as
                <code>bottom - top</code>. Make sure <code>right &gt; left</code> and <code>bottom &gt; top</code>.
            </p>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;// First rectangle: from (50, 40) to (200, 140)<br>
&nbsp;&nbsp;// width = 200 - 50 = 150, height = 140 - 40 = 100<br>
&nbsp;&nbsp;final rect1 = Rect.fromLTRB(50, 40, 200, 140);<br>
<br>
&nbsp;&nbsp;// Second rectangle: centered horizontally, positioned vertically<br>
&nbsp;&nbsp;// Left edge at 1/4 width, right edge at 3/4 width<br>
&nbsp;&nbsp;// Top at 1/3 height, bottom at 2/3 height<br>
&nbsp;&nbsp;final rect2 = Rect.fromLTRB(<br>
&nbsp;&nbsp;&nbsp;&nbsp;size.width / 4,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size.height / 3,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size.width * 3 / 4,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size.height * 2 / 3,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;final paint = Paint()..color = Colors.blue;<br>
&nbsp;&nbsp;canvas.drawRect(rect1, paint);<br>
&nbsp;&nbsp;canvas.drawRect(rect2, paint);<br>
<br>
&nbsp;&nbsp;// Draw LTRB points for rect1<br>
&nbsp;&nbsp;final pointPaint1 = Paint()..color = Colors.red;<br>
&nbsp;&nbsp;final pointRadius = 6.0;<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect1.left, rect1.top),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint1,<br>
&nbsp;&nbsp;); // Left-Top<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect1.right, rect1.top),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint1,<br>
&nbsp;&nbsp;); // Right-Top<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect1.left, rect1.bottom),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint1,<br>
&nbsp;&nbsp;); // Left-Bottom<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect1.right, rect1.bottom),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint1,<br>
&nbsp;&nbsp;); // Right-Bottom<br>
<br>
&nbsp;&nbsp;// Draw LTRB points for rect2<br>
&nbsp;&nbsp;final pointPaint2 = Paint()..color = Colors.green;<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect2.left, rect2.top),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint2,<br>
&nbsp;&nbsp;); // Left-Top<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect2.right, rect2.top),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint2,<br>
&nbsp;&nbsp;); // Right-Top<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect2.left, rect2.bottom),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint2,<br>
&nbsp;&nbsp;); // Left-Bottom<br>
&nbsp;&nbsp;canvas.drawCircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset(rect2.right, rect2.bottom),<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointPaint2,<br>
&nbsp;&nbsp;); // Right-Bottom<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/rect-ltrb.png" alt="Flutter Rect fromLTRB visual example">
                    <p class="image-caption">Visual guide showing how <code>Rect.fromLTRB()</code> creates rectangles
                        from four edge coordinates (left, top, right, bottom). Two blue rectangles are shown with corner
                        markers: red dots mark the four corners of the first rectangle (left, top, right, bottom), and
                        green dots mark the four corners of the second rectangle, clearly demonstrating how the LTRB
                        parameters define the rectangle boundaries.
                    </p>
                </div>
            </div>

            <h3 id="rect-fromcenter-fromcircle"><code>Rect.fromCenter</code> and <code>Rect.fromCircle</code></h3>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;final center = Offset(size.width / 2, size.height / 2);<br>
<br>
&nbsp;&nbsp;// Rect centered at canvas center<br>
&nbsp;&nbsp;final rectFromCenter = Rect.fromCenter(<br>
&nbsp;&nbsp;&nbsp;&nbsp;center: center,<br>
&nbsp;&nbsp;&nbsp;&nbsp;width: 120,<br>
&nbsp;&nbsp;&nbsp;&nbsp;height: 80,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Bounding box of a circle<br>
&nbsp;&nbsp;final circleBounds = Rect.fromCircle(center: center, radius: 50);<br>
<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectFromCenter,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.green<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 3,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;circleBounds,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.orange.withValues(alpha: 0.2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.fill,<br>
&nbsp;&nbsp;);<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/rect_from_center_or_circle.png"
                        alt="Flutter Rect fromCenter and fromCircle visual example">
                    <p class="image-caption">Visual guide showing how <code>Rect.fromCenter</code> and
                        <code>Rect.fromCircle</code> construct rectangles from intuitive parameters.
                    </p>
                </div>
            </div>

            <h3 id="rect-frompoints"><code>Rect.fromPoints(Offset a, Offset b)</code></h3>
            <p><strong>Purpose:</strong> Create a rect from any two opposite corners.</p>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;canvas.drawCircle(const Offset(30, 40), 5, Paint()..color = Colors.blue);<br>
&nbsp;&nbsp;canvas.drawCircle(const Offset(200, 160), 5, Paint()..color = Colors.red);<br>
<br>
&nbsp;&nbsp;final rect = Rect.fromPoints(const Offset(30, 40), const Offset(200, 160));<br>
<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;rect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.green<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 3,<br>
&nbsp;&nbsp;);<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/rect_from_points.png" alt="Flutter Rect fromPoints visual example">
                    <p class="image-caption">Visual guide showing how <code>Rect.fromPoints</code> creates a rectangle
                        from two opposite corner points.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>üìè Reading Rect Position & Size</h2>

            <h3>Edges: <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code></h3>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                    <span class="copy-text">Copy</span>
                </button>
                <code>
final rect = Rect.fromLTWH(20, 30, 100, 60);<br>
<br>
debugPrint('left: ${rect.left}');   // 20.0<br>
debugPrint('top: ${rect.top}');     // 30.0<br>
debugPrint('right: ${rect.right}'); // 120.0<br>
debugPrint('bottom: ${rect.bottom}'); // 90.0<br>
                </code>
            </div>

            <h3>Size: <code>width</code>, <code>height</code>, <code>size</code></h3>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                    <span class="copy-text">Copy</span>
                </button>
                <code>
final rect = Rect.fromLTWH(0, 0, 200, 100);<br>
<br>
final w = rect.width;   // 200.0<br>
final h = rect.height;  // 100.0<br>
final s = rect.size;    // Size(200, 100)<br>
                </code>
            </div>

            <h3>Corners & Center: <code>topLeft</code>, <code>bottomRight</code>, <code>center</code></h3>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                    <span class="copy-text">Copy</span>
                </button>
                <code>
final rect = Rect.fromLTWH(20, 30, 100, 60);<br>
<br>
final center = rect.center;        // Offset(70, 60)<br>
final tl = rect.topLeft;           // Offset(20, 30)<br>
final br = rect.bottomRight;       // Offset(120, 90)<br>
                </code>
            </div>

            <h3>Size helpers: <code>longestSide</code>, <code>shortestSide</code>, <code>isEmpty</code></h3>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                    <span class="copy-text">Copy</span>
                </button>
                <code>
final longest = rect.longestSide;   // max(width, height)<br>
final shortest = rect.shortestSide; // min(width, height)<br>
final empty = rect.isEmpty;         // width <= 0 or height <= 0<br>
                </code>
            </div>
        </section>

        <section class="section">
            <h2>‚úèÔ∏è Transforming Rects</h2>

            <h3><code>inflate(double delta)</code> / <code>deflate(double delta)</code></h3>
            <p><strong>Purpose:</strong> Grow or shrink a rect uniformly on all sides.</p>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;final center = Offset(size.width / 2, size.height / 2);<br>
<br>
&nbsp;&nbsp;// 1Ô∏è‚É£ Original rectangle (reference)<br>
&nbsp;&nbsp;final originalRect = Rect.fromCenter(<br>
&nbsp;&nbsp;&nbsp;&nbsp;center: center,<br>
&nbsp;&nbsp;&nbsp;&nbsp;width: 200,<br>
&nbsp;&nbsp;&nbsp;&nbsp;height: 120,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// 2Ô∏è‚É£ Inflated rectangle (bigger than original)<br>
&nbsp;&nbsp;final inflatedRect = originalRect.inflate(20);<br>
<br>
&nbsp;&nbsp;// 3Ô∏è‚É£ Deflated rectangle (smaller than original)<br>
&nbsp;&nbsp;final deflatedRect = originalRect.deflate(20);<br>
<br>
&nbsp;&nbsp;// üîµ Inflated rect (background)<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;inflatedRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()..color = Colors.blue.withValues(alpha: 0.15),<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// ‚ö™ Original rect (middle reference)<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;originalRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.black<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// üî¥ Deflated rect (inside)<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;deflatedRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.red<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/rect_inflate_deflate.png" alt="Flutter Rect inflate and deflate visual example">
                    <p class="image-caption">The black rectangle is the original rectangle. The blue rectangle is the
                        inflated rectangle. The red rectangle is the deflated rectangle. Both the inflated and deflated
                        are respected to the original rectangle.
                    </p>
                </div>
            </div>

            <h3><code>shift(Offset)</code> / <code>translate(dx, dy)</code></h3>
            <p><strong>Purpose:</strong> Move the rect to a new position without changing its size. Both methods
                perform the same operation but accept parameters differently.</p>
            <p><strong>What happens:</strong> The rectangle is moved by adding the offset values to all four edges
                (left, top, right, bottom), effectively translating the entire rectangle in 2D space.</p>
            <p><strong>Mathematical operation:</strong></p>
            <ul>
                <li>New <code>left = oldLeft + offset.dx</code></li>
                <li>New <code>top = oldTop + offset.dy</code></li>
                <li>New <code>right = oldRight + offset.dx</code></li>
                <li>New <code>bottom = oldBottom + offset.dy</code></li>
                <li>Width and height remain unchanged</li>
            </ul>
            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>shift(Offset offset)</code> - Takes a single <code>Offset</code> object with <code>dx</code>
                    and <code>dy</code> components</li>
                <li><code>translate(double dx, double dy)</code> - Takes separate <code>dx</code> (horizontal) and
                    <code>dy</code> (vertical) values
                </li>
            </ul>
            <p><strong>Return value:</strong> Returns a new <code>Rect</code> object at the new position. The original
                rect is not modified (Rects are immutable).</p>
            <p><strong>When to use:</strong></p>
            <ul>
                <li><strong>shift()</strong> - Use when you already have an <code>Offset</code> object or want to move
                    by a pre-calculated offset</li>
                <li><strong>translate()</strong> - Use when you have separate x and y values or want more explicit
                    control</li>
                <li>Both are functionally equivalent - choose based on what's more convenient for your code</li>
            </ul>
            <p><strong>Common use cases:</strong></p>
            <ul>
                <li>Repositioning UI elements</li>
                <li>Creating patterns by duplicating and moving rectangles</li>
                <li>Animating rectangle positions</li>
                <li>Aligning rectangles relative to other elements</li>
                <li>Creating grid layouts</li>
            </ul>
            <div class="info-box">
                <strong>üí° Key Points:</strong>
                <ul>
                    <li>Both methods return a <strong>new</strong> Rect - they don't modify the original</li>
                    <li>The rectangle's size (width and height) remains exactly the same</li>
                    <li>Positive <code>dx</code> moves right, negative moves left</li>
                    <li>Positive <code>dy</code> moves down, negative moves up</li>
                    <li>You can chain multiple shifts: <code>rect.shift(offset1).shift(offset2)</code></li>
                    <li>These methods are equivalent: <code>rect.shift(Offset(dx, dy))</code> and
                        <code>rect.translate(dx, dy)</code>
                    </li>
                </ul>
            </div>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;final originalRect = Rect.fromLTWH(50, 100, 100, 80);<br>
<br>
&nbsp;&nbsp;// Method 1: shift() - takes an Offset object<br>
&nbsp;&nbsp;final shiftedRect = originalRect.shift(const Offset(120, 0));<br>
<br>
&nbsp;&nbsp;// Method 2: translate() - takes separate dx, dy values<br>
&nbsp;&nbsp;final translatedRect = originalRect.translate(120, 150);<br>
<br>
&nbsp;&nbsp;// Draw all rectangles<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;originalRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.blue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 3,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;shiftedRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.green<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 3,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;translatedRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.red<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 3,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Labels<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Original',<br>
&nbsp;&nbsp;&nbsp;&nbsp;originalRect.topLeft.translate(-5, -20),<br>
&nbsp;&nbsp;&nbsp;&nbsp;Colors.blue,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'shift(Offset(120, 0))',<br>
&nbsp;&nbsp;&nbsp;&nbsp;shiftedRect.topLeft.translate(-5, -20),<br>
&nbsp;&nbsp;&nbsp;&nbsp;Colors.green,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'translate(120, 150)',<br>
&nbsp;&nbsp;&nbsp;&nbsp;translatedRect.topLeft.translate(-5, -20),<br>
&nbsp;&nbsp;&nbsp;&nbsp;Colors.red,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Info<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Both methods move rectangles.\nshift() uses Offset, translate() uses dx &amp; dy.',<br>
&nbsp;&nbsp;&nbsp;&nbsp;const Offset(50, 350),<br>
&nbsp;&nbsp;&nbsp;&nbsp;Colors.black,<br>
&nbsp;&nbsp;);<br>
}<br>
<br>
void _drawText(Canvas canvas, String text, Offset pos, Color color) {<br>
&nbsp;&nbsp;final textPainter = TextPainter(<br>
&nbsp;&nbsp;&nbsp;&nbsp;text: TextSpan(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: text,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style: TextStyle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: color,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontSize: 12,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontWeight: FontWeight.bold,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;textDirection: TextDirection.ltr,<br>
&nbsp;&nbsp;)..layout();<br>
&nbsp;&nbsp;textPainter.paint(canvas, pos);<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/rect_shift_translate.png" alt="Flutter Rect shift and translate visual example">
                    <p class="image-caption">Visual guide showing how <code>shift()</code> and <code>translate()</code>
                        move rectangles without changing their size. The blue rectangle is the original, the green
                        rectangle is moved horizontally using <code>shift(Offset(120, 0))</code>, and the red rectangle
                        is moved both horizontally and vertically using <code>translate(120, 150)</code>. All three
                        rectangles maintain the same dimensions, demonstrating that these methods only change position.
                    </p>
                </div>
            </div>

            <h3><code>overlaps</code> &amp; <code>intersect</code></h3>
            <p><strong>Purpose:</strong> Detect and calculate the intersection area between two rectangles. These
                methods
                work together to determine if rectangles overlap and find their common area.</p>

            <h4><code>overlaps(Rect other) ‚Üí bool</code></h4>
            <p><strong>Purpose:</strong> Check if two rectangles have any overlapping area (intersection).</p>
            <p><strong>What it does:</strong> Returns <code>true</code> if the rectangles share at least one point in
                common, <code>false</code> if they are completely separate or only touch at edges/corners.</p>
            <p><strong>Mathematical check:</strong></p>
            <ul>
                <li>Returns <code>true</code> if: <code>left &lt; other.right &amp;&amp; right &gt; other.left &amp;&amp;
                        top &lt; other.bottom &amp;&amp; bottom &gt; other.top</code></li>
                <li>Returns <code>false</code> if rectangles are adjacent (touching edges) or completely separate</li>
                <li>Edge cases: Rectangles that only touch at a corner or edge return <code>false</code></li>
            </ul>
            <p><strong>Return value:</strong> <code>bool</code> - <code>true</code> if there's an overlap,
                <code>false</code>
                otherwise.
            </p>

            <h4><code>intersect(Rect other) ‚Üí Rect</code></h4>
            <p><strong>Purpose:</strong> Calculate the rectangular area where two rectangles overlap.</p>
            <p><strong>What it does:</strong> Returns a new <code>Rect</code> representing the intersection area. If the
                rectangles don't overlap, returns an empty rect (<code>Rect.zero</code> or a rect with zero or negative
                dimensions).</p>
            <p><strong>Mathematical calculation:</strong></p>
            <ul>
                <li>Intersection <code>left = max(rect1.left, rect2.left)</code></li>
                <li>Intersection <code>top = max(rect1.top, rect2.top)</code></li>
                <li>Intersection <code>right = min(rect1.right, rect2.right)</code></li>
                <li>Intersection <code>bottom = min(rect1.bottom, rect2.bottom)</code></li>
                <li>If the calculated rect has zero or negative dimensions, the rectangles don't overlap</li>
            </ul>
            <p><strong>Return value:</strong> A new <code>Rect</code> representing the intersection, or an empty rect if
                there's no overlap.</p>

            <p><strong>Relationship between methods:</strong></p>
            <ul>
                <li>Always check <code>overlaps()</code> before calling <code>intersect()</code> to avoid working with
                    empty rects</li>
                <li><code>overlaps()</code> is faster - use it for quick checks</li>
                <li><code>intersect()</code> gives you the actual overlapping area - use it when you need the
                    dimensions</li>
            </ul>

            <p><strong>Common use cases:</strong></p>
            <ul>
                <li>Collision detection in games</li>
                <li>UI element overlap detection</li>
                <li>Calculating visible regions when rectangles overlap</li>
                <li>Clipping operations</li>
                <li>Layout calculations (e.g., preventing overlapping widgets)</li>
                <li>Hit testing between multiple rectangles</li>
            </ul>

            <div class="info-box">
                <strong>üí° Key Points:</strong>
                <ul>
                    <li><code>overlaps()</code> returns <code>false</code> for rectangles that only touch at edges or
                        corners</li>
                    <li><code>intersect()</code> may return an empty rect if rectangles don't overlap - always check
                        <code>overlaps()</code> first
                    </li>
                    <li>Both methods are commutative: <code>a.overlaps(b) == b.overlaps(a)</code></li>
                    <li>The intersection rect is always contained within both original rectangles</li>
                    <li>If <code>overlaps()</code> returns <code>true</code>, <code>intersect()</code> will return a
                        non-empty rect</li>
                    <li>Use <code>intersect().isEmpty</code> to verify if the intersection is valid</li>
                </ul>
            </div>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;// Example 1: overlaps() method (Top)<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;final a1 = Rect.fromLTWH(20, 20, 100, 60);<br>
&nbsp;&nbsp;final b1 = Rect.fromLTWH(80, 40, 100, 60);<br>
<br>
&nbsp;&nbsp;// Check if rectangles overlap using overlaps() method<br>
&nbsp;&nbsp;final overlapsResult = a1.overlaps(b1);<br>
<br>
&nbsp;&nbsp;// Draw original rectangles<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;a1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.blue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;b1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.green<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw text label for Example 1<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Example 1: overlaps() method\nResult: $overlapsResult',<br>
&nbsp;&nbsp;&nbsp;&nbsp;b1.bottomLeft.translate(100, 3),<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;// Example 2: intersect() method (Bottom)<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;final a2 = Rect.fromLTWH(20, size.height * 0.3, 100, 60);<br>
&nbsp;&nbsp;final b2 = Rect.fromLTWH(80, size.height * 0.35, 100, 60);<br>
<br>
&nbsp;&nbsp;// Check if rectangles overlap first<br>
&nbsp;&nbsp;if (a2.overlaps(b2)) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Calculate intersection area using intersect() method<br>
&nbsp;&nbsp;&nbsp;&nbsp;final intersection = a2.intersect(b2);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Draw the intersection area in orange (only if they overlap)<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas.drawRect(intersection, Paint()..color = Colors.orange);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// Draw original rectangles<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;a2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.blue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;b2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.green<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw text label for Example 2<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Example 2: intersect() method\nOrange area = intersection',<br>
&nbsp;&nbsp;&nbsp;&nbsp;b2.bottomLeft.translate(100, 3),<br>
&nbsp;&nbsp;);<br>
}<br>
<br>
void _drawText(Canvas canvas, String text, Offset position) {<br>
&nbsp;&nbsp;final painter = TextPainter(<br>
&nbsp;&nbsp;&nbsp;&nbsp;text: TextSpan(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: text,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style: const TextStyle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: Colors.black,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontSize: 16,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontWeight: FontWeight.bold,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;textAlign: TextAlign.center,<br>
&nbsp;&nbsp;&nbsp;&nbsp;textDirection: TextDirection.ltr,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;painter.layout();<br>
&nbsp;&nbsp;painter.paint(canvas, Offset(position.dx - painter.width / 2, position.dy));<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/overlaps-intersects.png"
                        alt="Flutter Rect overlaps and intersect visual example">
                    <p class="image-caption">Visual guide demonstrating both <code>overlaps()</code> and
                        <code>intersect()</code> methods. Example 1 (top) shows two overlapping rectangles (blue and
                        green) with the <code>overlaps()</code> result displayed. Example 2 (bottom) shows the same
                        rectangles with the intersection area highlighted in orange, demonstrating how
                        <code>intersect()</code> calculates the common area between overlapping rectangles.
                    </p>
                </div>
            </div>

            <h3><code>expandToInclude</code> / <code>union</code></h3>
            <p><strong>Purpose:</strong> Compute the smallest rectangle that contains both inputs. These methods are
                functionally equivalent and return a new rect that encompasses the original rect and another rect or
                point.</p>

            <h4><code>expandToInclude(Rect other) ‚Üí Rect</code></h4>
            <p><strong>Purpose:</strong> Expand the current rectangle to include another rectangle or point.</p>
            <p><strong>What it does:</strong> Returns a new rectangle that is the smallest possible rectangle containing
                both the original rectangle and the other rectangle/point.</p>
            <p><strong>Mathematical calculation:</strong></p>
            <ul>
                <li>New <code>left = min(rect1.left, rect2.left)</code></li>
                <li>New <code>top = min(rect1.top, rect2.top)</code></li>
                <li>New <code>right = max(rect1.right, rect2.right)</code></li>
                <li>New <code>bottom = max(rect1.bottom, rect2.bottom)</code></li>
            </ul>
            <p><strong>Special case:</strong> To include a point, create a zero-size rect at that point:
                <code>Rect.fromLTWH(point.dx, point.dy, 0, 0)</code>
            </p>

            <h4><code>union(Rect other) ‚Üí Rect</code></h4>
            <p><strong>Purpose:</strong> Calculate the union of two rectangles (same as <code>expandToInclude</code>).
            </p>
            <p><strong>What it does:</strong> Returns the smallest rectangle that contains both rectangles. This is an
                alias for <code>expandToInclude</code> - they produce identical results.</p>

            <p><strong>Relationship between methods:</strong></p>
            <ul>
                <li><code>expandToInclude()</code> and <code>union()</code> are functionally identical</li>
                <li>Both return a new rect that encompasses both input rects</li>
                <li>Use whichever name is more semantically clear for your use case</li>
                <li>If the other rect is already contained within the original, the result equals the original</li>
            </ul>

            <p><strong>Common use cases:</strong></p>
            <ul>
                <li>Calculating bounding boxes for multiple elements</li>
                <li>Expanding rectangles to include points or other shapes</li>
                <li>Layout calculations (finding container sizes)</li>
                <li>Collision detection (finding outer bounds)</li>
                <li>Viewport calculations</li>
                <li>Clipping region calculations</li>
            </ul>

            <div class="info-box">
                <strong>üí° Key Points:</strong>
                <ul>
                    <li>Both methods return a <strong>new</strong> Rect - they don't modify the original</li>
                    <li>The result is always the smallest rectangle that contains both inputs</li>
                    <li>If one rect is completely inside the other, the result is the larger rect</li>
                    <li>To include a point, create a zero-size rect: <code>Rect.fromLTWH(x, y, 0, 0)</code></li>
                    <li><code>expandToInclude()</code> and <code>union()</code> are equivalent - use either one</li>
                    <li>The union always has dimensions: <code>width = max(right) - min(left)</code> and
                        <code>height = max(bottom) - min(top)</code>
                    </li>
                </ul>
            </div>

            <div class="property-layout">
                <div class="property-code">
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)" title="Copy code">
                            <span class="copy-text">Copy</span>
                        </button>
                        <code>
@override<br>
void paint(Canvas canvas, Size size) {<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;// Example 1: expandToInclude() method (Top)<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;final originalRect = Rect.fromLTWH(20, 20, 80, 50);<br>
&nbsp;&nbsp;final pointToInclude = Offset(150, 60);<br>
<br>
&nbsp;&nbsp;// Expand rectangle to include the point<br>
&nbsp;&nbsp;// Create a zero-size rectangle at the point, then expand to include it<br>
&nbsp;&nbsp;final pointRect = Rect.fromLTWH(pointToInclude.dx, pointToInclude.dy, 0, 0);<br>
&nbsp;&nbsp;final expandedRect = originalRect.expandToInclude(pointRect);<br>
<br>
&nbsp;&nbsp;// Draw original rectangle<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;originalRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.blue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw expanded rectangle<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;expandedRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.purple<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw the point to include<br>
&nbsp;&nbsp;canvas.drawCircle(pointToInclude, 6, Paint()..color = Colors.red);<br>
<br>
&nbsp;&nbsp;// Draw text label for Example 1<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Example 1: expandToInclude() method\nPurple = expanded to include red point',<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointToInclude.translate(0, 40),<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;// Example 1: expandToInclude() method (Top)<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;final originalRect2 = Rect.fromLTWH(20, 220, 80, 50);<br>
&nbsp;&nbsp;final pointToInclude2 = Offset(60, 160);<br>
<br>
&nbsp;&nbsp;// Expand rectangle to include the point<br>
&nbsp;&nbsp;// Create a zero-size rectangle at the point, then expand to include it<br>
&nbsp;&nbsp;final pointRect2 = Rect.fromLTWH(<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointToInclude2.dx,<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointToInclude2.dy,<br>
&nbsp;&nbsp;&nbsp;&nbsp;0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;0,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;final expandedRect2 = originalRect2.expandToInclude(pointRect2);<br>
<br>
&nbsp;&nbsp;// Draw original rectangle<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;originalRect2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.blue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw expanded rectangle<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;expandedRect2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.purple<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw the point to include<br>
&nbsp;&nbsp;canvas.drawCircle(pointToInclude2, 6, Paint()..color = Colors.red);<br>
<br>
&nbsp;&nbsp;// Draw text label for Example 1<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Example 1: expandToInclude() method\nPurple = expanded to include red point',<br>
&nbsp;&nbsp;&nbsp;&nbsp;pointToInclude.translate(0, 40),<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;// Example 2: union() method (Bottom)<br>
&nbsp;&nbsp;// ============================================<br>
&nbsp;&nbsp;final rectA = Rect.fromLTWH(20, size.height * 0.5, 80, 50);<br>
&nbsp;&nbsp;final rectB = Rect.fromLTWH(120, size.height * 0.55, 80, 50);<br>
<br>
&nbsp;&nbsp;// Calculate union rectangle (smallest rect containing both)<br>
&nbsp;&nbsp;// Manually calculate: find min left/top and max right/bottom<br>
&nbsp;&nbsp;final unionRect = Rect.fromLTRB(<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectA.left &lt; rectB.left ? rectA.left : rectB.left,<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectA.top &lt; rectB.top ? rectA.top : rectB.top,<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectA.right &gt; rectB.right ? rectA.right : rectB.right,<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectA.bottom &gt; rectB.bottom ? rectA.bottom : rectB.bottom,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw union rectangle (filled with semi-transparent color)<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;unionRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.orange.withValues(alpha: 0.3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.fill,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;unionRect,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.orange<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw original rectangles<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectA,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.blue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
&nbsp;&nbsp;canvas.drawRect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;rectB,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Paint()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..color = Colors.green<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..style = PaintingStyle.stroke<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..strokeWidth = 2,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;// Draw text label for Example 2<br>
&nbsp;&nbsp;_drawText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;canvas,<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Example 2: union() method\nOrange = smallest rect containing both',<br>
&nbsp;&nbsp;&nbsp;&nbsp;unionRect.bottomLeft.translate(unionRect.width / 2, 20),<br>
&nbsp;&nbsp;);<br>
}<br>
<br>
void _drawText(Canvas canvas, String text, Offset position) {<br>
&nbsp;&nbsp;final painter = TextPainter(<br>
&nbsp;&nbsp;&nbsp;&nbsp;text: TextSpan(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: text,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style: const TextStyle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: Colors.black,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontSize: 16,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontWeight: FontWeight.bold,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;textAlign: TextAlign.center,<br>
&nbsp;&nbsp;&nbsp;&nbsp;textDirection: TextDirection.ltr,<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;painter.layout();<br>
&nbsp;&nbsp;painter.paint(canvas, Offset(position.dx - painter.width / 2, position.dy));<br>
}<br>
                        </code>
                    </div>
                </div>

                <div class="property-image">
                    <img src="../assets/expand-to-include-union.png"
                        alt="Flutter Rect expandToInclude and union visual example">
                    <p class="image-caption">Visual guide demonstrating <code>expandToInclude()</code> and
                        <code>union()</code> methods. Example 1 (top) shows two scenarios where a blue rectangle is
                        expanded (purple outline) to include a red point. Example 2 (bottom) shows two rectangles (blue
                        and green) with their union represented by an orange-filled rectangle, demonstrating how
                        <code>union()</code> calculates the smallest rectangle containing both.
                    </p>
                </div>
            </div>
        </section>



        <section class="section">
            <h2>üìã Rect API Reference Table</h2>

            <h3>Properties</h3>
            <table>
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>left</code></td>
                        <td><code>double</code></td>
                        <td>X coordinate of the left edge</td>
                    </tr>
                    <tr>
                        <td><code>top</code></td>
                        <td><code>double</code></td>
                        <td>Y coordinate of the top edge</td>
                    </tr>
                    <tr>
                        <td><code>right</code></td>
                        <td><code>double</code></td>
                        <td>X coordinate of the right edge</td>
                    </tr>
                    <tr>
                        <td><code>bottom</code></td>
                        <td><code>double</code></td>
                        <td>Y coordinate of the bottom edge</td>
                    </tr>
                    <tr>
                        <td><code>width</code></td>
                        <td><code>double</code></td>
                        <td>Rect width (<code>right - left</code>)</td>
                    </tr>
                    <tr>
                        <td><code>height</code></td>
                        <td><code>double</code></td>
                        <td>Rect height (<code>bottom - top</code>)</td>
                    </tr>
                    <tr>
                        <td><code>size</code></td>
                        <td><code>Size</code></td>
                        <td>Combined width and height</td>
                    </tr>
                    <tr>
                        <td><code>topLeft</code></td>
                        <td><code>Offset</code></td>
                        <td>Corner at (<code>left</code>, <code>top</code>)</td>
                    </tr>
                    <tr>
                        <td><code>topRight</code></td>
                        <td><code>Offset</code></td>
                        <td>Corner at (<code>right</code>, <code>top</code>)</td>
                    </tr>
                    <tr>
                        <td><code>bottomLeft</code></td>
                        <td><code>Offset</code></td>
                        <td>Corner at (<code>left</code>, <code>bottom</code>)</td>
                    </tr>
                    <tr>
                        <td><code>bottomRight</code></td>
                        <td><code>Offset</code></td>
                        <td>Corner at (<code>right</code>, <code>bottom</code>)</td>
                    </tr>
                    <tr>
                        <td><code>center</code></td>
                        <td><code>Offset</code></td>
                        <td>Center point of the rect</td>
                    </tr>
                    <tr>
                        <td><code>isEmpty</code></td>
                        <td><code>bool</code></td>
                        <td><code>true</code> if width ‚â§ 0 or height ‚â§ 0</td>
                    </tr>
                    <tr>
                        <td><code>longestSide</code></td>
                        <td><code>double</code></td>
                        <td><code>max(width, height)</code></td>
                    </tr>
                    <tr>
                        <td><code>shortestSide</code></td>
                        <td><code>double</code></td>
                        <td><code>min(width, height)</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Constructors / Static Members</h3>
            <table>
                <thead>
                    <tr>
                        <th>Constructor / Static</th>
                        <th>Parameters</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>Rect.fromLTWH</code></td>
                        <td><code>double left, top, width, height</code></td>
                        <td>Create rect from left/top and size</td>
                    </tr>
                    <tr>
                        <td><code>Rect.fromLTRB</code></td>
                        <td><code>double left, top, right, bottom</code></td>
                        <td>Create rect from all four edges</td>
                    </tr>
                    <tr>
                        <td><code>Rect.fromCircle</code></td>
                        <td><code>Offset center, double radius</code></td>
                        <td>Bounding box of a circle</td>
                    </tr>
                    <tr>
                        <td><code>Rect.fromCenter</code></td>
                        <td><code>Offset center, double width, double height</code></td>
                        <td>Rect centered at a point</td>
                    </tr>
                    <tr>
                        <td><code>Rect.fromPoints</code></td>
                        <td><code>Offset a, Offset b</code></td>
                        <td>Create rect from two opposite corners</td>
                    </tr>
                    <tr>
                        <td><code>Rect.zero</code></td>
                        <td>‚Äì</td>
                        <td>Rect at (0,0) with zero size</td>
                    </tr>
                    <tr>
                        <td><code>Rect.largest</code></td>
                        <td>‚Äì</td>
                        <td>Very large rect (effectively "infinite" bounds)</td>
                    </tr>
                    <tr>
                        <td><code>Rect.lerp</code></td>
                        <td><code>Rect? a, Rect? b, double t</code></td>
                        <td>Linear interpolation between two rects</td>
                    </tr>
                </tbody>
            </table>

            <h3>Methods</h3>
            <table>
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Parameters</th>
                        <th>Return Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>contains(Offset point)</code></td>
                        <td><code>Offset point</code></td>
                        <td><code>bool</code></td>
                        <td>Returns true if point lies inside the rect</td>
                    </tr>
                    <tr>
                        <td><code>overlaps(Rect other)</code></td>
                        <td><code>Rect other</code></td>
                        <td><code>bool</code></td>
                        <td>True if rects have non‚Äëempty intersection</td>
                    </tr>
                    <tr>
                        <td><code>intersect(Rect other)</code></td>
                        <td><code>Rect other</code></td>
                        <td><code>Rect</code></td>
                        <td>Intersection area of two rects</td>
                    </tr>
                    <tr>
                        <td><code>expandToInclude(Rect other)</code></td>
                        <td><code>Rect other</code></td>
                        <td><code>Rect</code></td>
                        <td>Smallest rect containing both</td>
                    </tr>
                    <tr>
                        <td><code>union(Rect other)</code></td>
                        <td><code>Rect other</code></td>
                        <td><code>Rect</code></td>
                        <td>Alias for <code>expandToInclude</code> (in practice)</td>
                    </tr>
                    <tr>
                        <td><code>inflate(double delta)</code></td>
                        <td><code>double delta</code></td>
                        <td><code>Rect</code></td>
                        <td>Grows rect outward by delta on all sides</td>
                    </tr>
                    <tr>
                        <td><code>deflate(double delta)</code></td>
                        <td><code>double delta</code></td>
                        <td><code>Rect</code></td>
                        <td>Shrinks rect inward by delta on all sides</td>
                    </tr>
                    <tr>
                        <td><code>shift(Offset offset)</code></td>
                        <td><code>Offset offset</code></td>
                        <td><code>Rect</code></td>
                        <td>Moves rect by the given offset</td>
                    </tr>
                    <tr>
                        <td><code>translate(double dx, double dy)</code></td>
                        <td><code>double dx, double dy</code></td>
                        <td><code>Rect</code></td>
                        <td>Moves rect by dx/dy</td>
                    </tr>
                </tbody>
            </table>

            <h3>Operators</h3>
            <table>
                <thead>
                    <tr>
                        <th>Operator</th>
                        <th>Usage</th>
                        <th>Return Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>==</code></td>
                        <td><code>rect1 == rect2</code></td>
                        <td><code>bool</code></td>
                        <td>Compares all fields for equality</td>
                    </tr>
                </tbody>
            </table>

            <div class="success-box">
                <strong>‚úÖ Key Takeaway:</strong> <strong>Rect</strong> is your primary tool for describing regions on
                the
                canvas. You use it to define bounds, clipping areas, hit‚Äëtest regions and layout boxes. Mastering Rect
                makes it much easier to position and size everything you draw with CustomPainter.
            </div>
        </section>
        <section class="section">
            <h2>üñºÔ∏è Visual Guide</h2>
            <p>
                Here is a comprehensive visual guide to the Rect class:
            </p>

            <div class="example-images">
                <div class="example-item">
                    <img src="../assets/rect-infographics.png" alt="Flutter Rect Class Complete Visual Guide">
                    <p class="image-caption">Complete Visual Guide to Flutter's Rect Class</p>
                </div>
            </div>
        </section>
    </div>


    <button id="backToTop" class="back-to-top" title="Back to top" aria-label="Back to top">
        <span>‚Üë</span>
        <span>Back to top</span>
    </button>

    <script>
        // Back to Top Button Functionality
        document.addEventListener('DOMContentLoaded', function () {
            const backToTopButton = document.getElementById('backToTop');

            if (backToTopButton) {
                window.addEventListener('scroll', () => {
                    if (window.pageYOffset > 300) {
                        backToTopButton.classList.add('show');
                    } else {
                        backToTopButton.classList.remove('show');
                    }
                });

                backToTopButton.addEventListener('click', () => {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
            }
        });

        // Copy Code Functionality
        function copyCode(button) {
            const codeBlock = button.parentElement;
            const codeElement = codeBlock.querySelector('code');

            if (!codeElement) return;

            let text = codeElement.innerHTML;
            text = text.replace(/<br\s*\/?>/gi, '\n');
            text = text.replace(/&nbsp;/g, ' ');

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            text = tempDiv.textContent || tempDiv.innerText || '';

            navigator.clipboard.writeText(text).then(() => {
                const copyText = button.querySelector('.copy-text');
                const originalText = copyText.textContent;
                copyText.textContent = 'Copied!';
                button.classList.add('copied');

                setTimeout(() => {
                    copyText.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy code:', err);
                alert('Failed to copy code. Please try again.');
            });
        }
    </script>
</body>

</html>